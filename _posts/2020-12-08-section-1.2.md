---
layout: post
title:  "Section 1.2 (induction)"
date:   2020-12-08 08:00:00 -0700
categories: taobataocp
---

This section is mostly about proof by induction and how it can be used to prove algorithm correctness.  Again, we look at Euclid's algorithm (the extended version this time).

Some highlights: Knuth formulates "proof by induction" as an algorithm which tracks with how I learned about it in my discrete math class (prove P(1), then prove P(n) => P(n +1))

In terms of using induction algorithms, he talks abotu the "inductive step" as it relates to preconditions and postconditions.  If you clearly lay out invariants before/after each step, proving then proof by induction requires showing that precondition + step => postcondition.  Intuition for useful/accurate assertions come from stepping through the algorithm on example inputs.

I think that's a useful frame that I use subconsciously or even consciously when coding (and often when talking with students).  What do you know at this point in the code?  I guess this also sort of explains why naming is important/difficult.  Good names imply that you understand the invariants.  I always find Euclid's algorithm confusing, I think maybe because the names aren't very useful: m, n, a, b, a', b' t, t' ... great.

Again, I think this level of formalism is rarely necessary (or at least ain't nobody got time for it), but there's some insights there that ring true in my experience.
